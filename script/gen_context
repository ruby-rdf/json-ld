#!/usr/bin/env ruby
# Generate a context for schema.org from the RDFS definition.
# Include the RDFS definition recursed
require 'rubygems'
require "bundler/setup"
$:.unshift(File.expand_path("../../lib", __FILE__))
begin
  require 'linkeddata'
rescue LoadError
end
require 'json/ld'
require 'getoptlong'
require 'rdf/rdfa'
require 'json/ld'

options = {
  output: STDOUT,
  prefixes: {},
  simple_compact_iris: true
}
input = nil

OPT_ARGS = [
  ["--body",          GetoptLong::NO_ARGUMENT,      "Include the vocabulary definition in the body of the document"],
  ["--language",      GetoptLong::REQUIRED_ARGUMENT,"Default language for vocabulary"],
  ["--output", "-o",  GetoptLong::REQUIRED_ARGUMENT,"Output to the specified file path"],
  ["--prefix",        GetoptLong::REQUIRED_ARGUMENT,"space-separated prefix uri combination"],
  ["--quiet",         GetoptLong::NO_ARGUMENT,      "Supress most output other than progress indicators"],
  ["--verbose",       GetoptLong::NO_ARGUMENT,      "Detail on execution"],
  ["--vocab",         GetoptLong::REQUIRED_ARGUMENT,"Set context @vocab to specified URI"],
  ["--help", "-?",    GetoptLong::NO_ARGUMENT,      "This message"]
]
def usage
  STDERR.puts %{Usage: #{$0} [options] URL ...}
  width = OPT_ARGS.map do |o|
    l = o.first.length
    l += o[1].length + 2 if o[1].is_a?(String)
    l
  end.max
  OPT_ARGS.each do |o|
    s = "  %-*s  " % [width, (o[1].is_a?(String) ? "#{o[0,2].join(', ')}" : o[0])]
    s += o.last
    STDERR.puts s
  end
  exit(1)
end


opts = GetoptLong.new(*OPT_ARGS.map {|o| o[0..-2]})

opts.each do |opt, arg|
  case opt
  when '--body'         then options[:include_body] = true
  when '--language'     then options[:language] = arg
  when '--output'       then options[:output] = File.open(arg, "w")
  when '--quiet'        then options[:quiet] = true
  when '--prefix'       then pfx,uri = arg.split(' '); options[:prefixes][pfx.to_sym] = uri
  when '--vocab'        then options[:vocab] = arg
  when '--help'         then usage
  end
end

# Load vocabulary
graph = RDF::Graph.load(ARGV[0])
context = JSON::LD::Context.new(options).from_vocabulary(graph)

# Simply serialize with the generated context
if options[:include_body]
  JSON::LD::Writer.new(options[:output], context: context, standard_prefixes: true) {|w| w << graph}
else
  options[:output].puts(context.serialize.to_json(JSON::LD::JSON_STATE))
end

#object_map = {}
#
## Extract IDs
#RDF::Repository.load("http://schema.org/docs/schema_org_rdfa.html") do |repo|
#  JSON::LD::API.fromRDF(repo) do |expanded|
#    JSON::LD::API.compact(expanded, context) do |compacted|
#      compacted['@graph'].each do |obj|
#        next if type_exclusion.include?(obj['name'])
#        object_map[obj['@id']] = obj if obj['@type'] == "rdfs:Class"
#      end
#    end
#  end
#end
#
#thing = object_map['schema:Thing']
#
## Build type heirarchy
#object_map.each do |id, obj|
#  [obj['rdfs:subClassOf']].flatten.compact.each do |super_class|
#    so = object_map[super_class]
#    next if so.nil?
#    raise "super class not found: #{super_class}" if so.nil?
#    (so['children'] ||= []) << obj
#  end
#end
#
#context = context.merge({"children" => {"@reverse" => "rdfs:subClassOf"}})
#context = {"@context" => context}
#puts context.merge(thing).to_json(JSON::LD::JSON_STATE)